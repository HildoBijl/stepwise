# The Step-Wise exercise system

To practice skills on Step-Wise, the students do exercises. There are a couple of things that every exercise has in common, but there are also different types of exercises. Let's study the commonalities and the differences.


## The basic building blocks of every exercise

Every exercise has an `exerciseId`. Correspondingly, there are two files.

- One file is in the `shared/edu/exercises/exercises` folder. This contains the shared exercise data needed by both the front-end and the API.
- One file is in the `frontend/src/ui/edu/exercises/exercises` folder. This contains info on how to display the exercise.

Below we discuss the shared exercise file. To read more about the way exercises are displayed, see the [exercise front-end readme](../../../frontend/src/ui/edu/exercises/).


## The shared exercise file

The shared exercise file contains an object as export. For every type of exercise, this object should at least have the following properties.

- A `data` object. This object can have various properties (you can plug in whatever you like) but it should at least have one of the following two properties.
	- A `skill` parameter (string) which contains a `skillId`. The exercise is then directly coupled with that skill: the difficulty of the exercise equals the difficulty of the given skill.
	- A `setup` parameter (setup object) which contains the steps needed to solve the exercise. The difficulty of the exercise is then determined based on the difficulty of the given skills. (Note that, for exercises, only the `and`, `or` and `repeat` setup functions are allowed.)

	The above information is then used to guage the difficulty of the given exercise for a student. It is possible (and quite common) to define both of the above parameters. For example, an exercise for a follow-up skill `X` could have a setup `and(A, B, C)`. If both are given, all data is combined to make a better estimate of the exercise difficulty.
- A `generateState` function. This function gets no input, and should return a randomly generated state for the exercise. For example, for the exercise "Calculate `a + b`" the generated state could look like `{ a: 23, b: 82 }`.
Note: the `generateState` function may return certain complex objects like a `FloatUnit` object. This is processed accordingly behind the scenes.
- A `processAction` function. This function works just like a [reducer](https://css-tricks.com/understanding-how-reducers-are-used-in-redux/). It gets an object as input with five properties:
	- The current `progress` object of the exercise. This object is used to keep track of the progress of the student in this exercise. It starts as an empty object `{}` but can be filled with whatever the exercise needs. For instance, after a while it may look like `{ step1done: true, step2done: true }` or `{ atStep: 3 }` or whatever.
	- A given `action`. Again, this can be any type of object, but a common action is `{ type: "input", input: { ans: 105 } }` or `{ type: "giveUp" }`.
	- The exercise `state`. This is the one originally generated by the `generateState` function.
	- The `history` array. This array is tracked behind the scenes but will look like `[{ action: { ... }, progress: { ... } }, ..., { action: { ... }, progress: { ... } }]`. So it contains the first action, the progress *after* this action, the second action, the progress *after* this action, and so forth. (Note that the initial progress is always `{}` so it's omitted from the history.) It is much cleaner to *never* use the history object in the `processAction` function, making it a clean reducer. However, in some very rare cases it may be useful.
	- An `updateSkills` function. When the student has successfully solved or failed at a certain skill, the `processAction` function should call the given `updateSkills` function. The syntax for this is `updateSkills(setup, true)` on a correct solution and `updateSkills(setup, false)` on an incorrect one. The given `setup` can be a `skillId` or any setup object. (Note: it must be an exercise-type setup, so only `and`, `or` and `repeat` functions may be used.) For instance, if the student failed a step that could be solved using either skill `A` or `B`, use `updateSkills(or("A", "B"), false)`. This is then processed accordingly. (That is, on the server, skill mastery scores are adjusted in the database. For offline users the `updateSkills` function is an empty (no-op) function.)
	
	The `processAction({ progress, action, state, history, updateSkills })` function should finally return a new `progress` object. For example, it could return `{ atStep: 4 }`, but in theory any desired `progress` object is possible.


## Extra rules from the Step-Wise API

The Step-Wise API is responsible for making the above happen. There are two actions in the API.

- `startExercise` (input: `skillId`) will start a new exercise for the given skill. If there already is an exercise active for the skill, this will throw an error. A skill can never have multiple exercises active simultaneously.
- `submitExerciseAction` (input: `skillId` and `action`) will submit an action for the exercise connected to the given skill. If the skill has no exercise active, this will throw an error.

When an exercise is done, the Step-Wise API expects every exercise to set a parameter `done` to `true` (or truthy) within the `progress` object. When this is done, it notes that the exercise is finished. (It is customary, though not obligatory, to use either `{ done: true, solved: true }` or `{ done: true, givenUp: true }` as final progress object, possibly with extra info, to indicate the outcome of an exercise.)


## Specific types of exercises

So far we have explained exercises in their most general form. Any exercise satisfying the above requirements is a valid exercise. Now we will look at specific types of exercises, which are used more commonly.


### The SimpleExercise type

The `SimpleExercise` is an exercise which can receive an input (possibly with multiple numbers or pieces of data) which is then judged as "correct" or "incorrect". It doesn't get any simpler than that.

To set up a `SimpleExercise` exercise, follow the following steps.

- Set up the `data` object as usual.
- Set up a `generateState()` function as usual.
- (Optional) Set up a `getSolution(state)` function, which takes the state and calculates a multitude of useful numbers, including the correct answer(s) of the exercise. For the exercise "Calculate `a + b`" this function could be `({ a, b }) => ({ a, b, ans: a + b })`.
- Set up a `checkInput(state, input)` function, which takes the state and an input, and returns `true` or `false`: is the input correct or not?
- Use `processAction = getSimpleExerciseProcessor(checkInput, data)` as the `processAction` function. 
- Assemble all parameters into the export object. (Definitely the obligatory `data`, `generateState` and `processAction`, but usually also the `checkInput` and `processAction`.)

That is all! The resulting exercise will take two types of actions then.

- An input action: `{ type: "input", input: { ... } }`. An incorrect input will keep the `progress` object empty: `{}`. A correct input will turn it into `{ done: true, solved: true }`.
- A give-up action: `{ type: "giveUp" }`. This will turn the `progress` object into `{ done: true, givenUp: true }`.

To program exercises for the front-end, see the [exercise front-end readme](../../../frontend/src/ui/edu/exercises/).


### The StepExercise type

For the `StepExercise` there is a basic and an advanced way of setting it up.

#### The basic way of using the `StepExercise`

While the `SimpleExercise` only has a main question, the `StepExercise` also has steps. The flow is as follows.

- If the student starts the exercise, he gets the main question. (Think of "Calculate `42 + 8*2`.") They can submit an answer as often as they like.
	- If the student gets it correct, the whole exercise is done.
	- If the student gives up on the main question, we transition to a Step-Wise mode. The student hence gets step 1. (Think of "What comes first? Multiplication or addition?") Again, they can submit an answer as often as they like.
		- If the student solves step 1, or gives up on step 1, they go to step 2. (Think of "What is `8*2`?")
		- If the student solves step 2, or gives up on step 2, they go to step 3. (Think of "What is `42 + 16`?")
		- And so forth... Usually the final step requires them to solve the original exercise.

To define a `StepExercise` exercise, do everything the same as for the `SimpleExercise`. There are only two differences.

- The `data` object should have a property `steps`. This must be an array with the skills or (skill setups) for each step. For instance, we could have `steps = [or('skill1', 'skill2'), null, 'skill3']`. In this case there are three steps: the student can use either `skill1` or `skill2` to solve the first step, no (currently existing) skill is required for step 2 (hence the placeholder `null`) and step 3 needs to be solved using `skill3`.
- The `checkInput` function now has the syntax `checkInput(state, input, step)`. While the student is at the main exercise, `step` is `0` (and hence falsy). The steps subsequently count as step `1`, step `2`, and so forth. The `checkInput` function should then check whether the given `input` is correct **for the given `step`**. (Hint: use a `switch` statement and combine the checks for the last step and the main exercise.)

#### Using substeps

For exercises where you can do steps simultaneously, it is wise to use substeps. As an example, imagine that a student has to solve `3*9 + 8*7`. In this case we could set the exercise up in either of two ways.

- Method 1: use four separate steps. Step 1: determine the order of operations. Step 2: calculate `3*9`. Step 3: calculate `8*7`. Step 4: calculate `27 + 56`.
- Method 2: let the student do the multiplications simultaneously! Then we use three steps. Step 1: determine the order of operations. Step 2: perform both multiplication `3*9` and `8*7`. Step 3: calculate `27 + 56`.

For the second method, note that the two substeps can be done simultaneously: there is no required order. We don't first have to calculate `3*9` before we can calculate `8*7`. However, we also shouldn't merge this in one big step: if the student gets `7*8` correct but messes up `3*9`, they should get this feedback, and the skill mastery scores should be updated accordingly.

To implement substeps, follow the following steps.

- Adjust the `steps` array in the `data` object. In this case we have `steps = ['operationOrder', ['multiplication', 'multiplication'], 'summation']`. Note that array within the array.
- Extend the `checkInput` to the syntax `checkInput(state, input, step, substep)`. Note that the `substep` is only defined when the current `step` actually has substeps. Just like steps, substeps start counting at `1`. You can *never* have `substep = 0`.

Finally, you use `processAction = getStepExerciseProcessor(checkInput, data)` as the `processAction` function, just like previously. Assemble all parameters in the export object and your exercise (at least for the back-end) is done!

#### The updating of the progress

What does the `progress` object look like for the `StepExercise`? Initially it starts as an empty object `{}`. If the student does *not* split up the exercise, this works the same as for the `SimpleExercise`. However, if the student *does* split up the exercise, we get the following `progress` objects.

- Right after splitting up the exercise, we have `progress = { split: true, step: 1, 1: {} }`.
- After completing step 1, we have `progress = { split: true, step: 2, 1: { solved: true, done: true }, 2: {} }`. If the student instead gave up, we have `progress = { split: true, step: 2, 1: { givenUp: true, done: true }, 2: {} }`.
- Suppose step 2 has two substeps. If the student gets the second substep correct but fails the first, we have `progress = { split: true, step: 2, 1: { solved: true, done: true }, 2: { 2: true } }`. (Note that only successful work is noted.) If the student subsequently gives up on step 2, then we have `progress = { split: true, step: 3, 1: { solved: true, done: true }, 2: { 2: true, givenUp: true, done: true }, 3: {} }`. (Note that earlier additions are kept.)
- If the student then gives up on step 3, we end with `progress = { split: true, step: 3, 1: { solved: true, done: true }, 2: { 2: true, givenUp: true, done: true }, 3: { givenUp: true, done: true}, done: true }`. Note that we use `done: true` to indicate the exercise is finished. We leave old parameters (even `step: 3`) to indicate the progress the student has made while making the exercise.

Understanding the progress object is useful if you want to display the proper feedback to the work of students.


### Other exercises

Currently there are no other exercise types. But of course you can create your own exercise from scratch if you like. All it takes is a `generateState` function and a `processAction` function. That's it! (Well, it's a bit easier said than done.)