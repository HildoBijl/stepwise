# Exercise system notes

The exercise system is based on skills and exercises. Let's take a look at what they entail.

## Skills

A skill is something you can do. Like "solve a linear equation". It may have prerequisites, like "multiply numbers". This turns all skills into a huge skill tree. This is defined in the shared repository, in `edu/skills.js`.

Every skill also has one or more exercises connected to it. These exercises can help you practice said skill. Some exercises may belong to multiple skills, if it practices both skills.

## Exercises

When practicing, you practice an exercise. When you want to make exercises, you should know that there are various types. I do assume you know React, because without it it's impossible to make exercises.

### Most general

In its most general form an exercise has these elements.

- `exerciseId`: a unique ID (a string) for the exercise.
- `data`: some meta-data about the exercise. It must either have a `skill` property to indicate which skill is being practiced or (even better) a `setup` property describing (using a `skill combiner`) which skills need to be executed to solve the exercise. Any other data may also be added.
- `generateState()`: a function defined in the `shared/edu/exercises/[exerciseId].js` file. It returns a state through which a problem can be generated. For instance, for the exercise "solve a*x = b" the state can be `{ a: 3, b: 18 }`.
- `processAction({ action, state, progress, history, updateSkills })`: a reducer-like function (defined in the same file) that takes an action (for instance `{type: "input", input: { ans: 6 }}`), a state and a previous progress parameter and returns a new progress parameter. This is the heart of the exercise: it determines if the action solves the exercise or not. There are a few special things to keep in mind here.
..- When the progress has a parameter `{ done: true }` then the exercise is registered as done. It means no further actions are possible. However, a new exercise can be started. (It is not possible to start a new exercise when the previous one isn't done.)
..- The updateSkills function is used on the server to update the skill ratings for the respective skills. More on this later.
- An `Exercise` component in the `frontend/src/ui/practice/exercises/[exerciseId].js` file. This is a React component displaying the exercise to the user. It has access to a variety of data that is provided in a React Context. To access it, first use `import { useExerciseData } from '../ExerciseContainer'` as import, followed by `const { ... } = useExerciseData()` in the exercise. As parameters you can get
..- `state`: the state generated by `generateState`.
..- `progress`: the last progress for the exercise..
..- `history`: an array `[{action: { ... }, progress: { ... }}]` of earlier actions with resulting progress objects. The initial `progress` is always an empty object `{}` so this is not in the history. The last progress equals the progress parameter.
..- `submitting`: a boolean that is set to true when an action has been submitted to the server and we're still waiting for a response.
..- `submitAction(action)`: the function used to submit an action to the server.
..- `startNewExercise()`: the function used to start up a new exercise. This can only be called when the exercise is done.
..- `shared`: all the objects exported from the shared file for this exercise, including `generateState` and `processAction` but also anything else that's exported.
..- `skillId`: the ID of the skill that's currently being practiced.

That is all there is to an exercise. Based on this you can build whatever you want. The possibilities are endless.

### SimpleExercise

If you don't want endless possibilities, but a simple exercise, then you can go for the `SimpleExercise` format. This is an easy way to make an Exercise with just a single question.

To set up a `SimpleExercise`, do the following steps.

- Define the `generateState` function as usual, in the shared file.
- In the same file add a `checkInput(state, input)` function. This function should return true if the input is correct and false if it is not.
- Also in the shared file define the required `processAction` function as `getSimpleExerciseProcessor(checkInput)`. This generates a `processAction` function for you, based on the `checkInput` function you just wrote.
- In the frontend file for the exercise, define two React components `Problem = (state) => { ... }` and `Solution = (state) => { ... }`. Then set up a default export `Exercise = () => <SimpleExercise Problem={Problem} Solution={Solution} />`.

That's all! The SimpleExercise components lays everything else out. It also adds buttons to the bottom to submit the input or give up on an exercise.

There's a few things that are important when setting up a Problem. Let's walk through them.

#### Input fields

In a Problem you can set up input fields. For instance, you can write `<IntegerInput name="ans" />`. Because a SimpleExercise wraps a form around everything, input is automatically registered. You don't have to do anything, other than define the input field like this with the corresponding name.

If you want to access the input, or set your own parameters, you can use `import { useFormData } from '../../form/Form'` and then `const { ... } = useFormData()`. This gets you access to all the information from the form. This includes:

- `input`: all the input data in one object, like `{x: {type: 'Integer', value: '-42'}}`.
- `setParameter(name, value)`: will store the value in the given input parameter. So you can use `setParameter('x', {type: 'Integer', value: '-42'})`.
- `deleteParameter(name)`: will delete an input parameter.
- `setParameters(newInput, override = false)`: will set the `newInput` object as the new input. It will merge with the old object, unless override is set to true, in which case the old input will be thrown out entirely.
- `clearForm()`: deletes all input and sets it back to `{}`.
- `validation`: an object with validation data. More on this right after this list.
- `validationInput`: the input for which the validation was last executed.
- `isValid`: the function that validates the input. Returns `true` or `false`. It also updates the validation object and sets the validation input to the current input.
- `saveValidationFunction(name, validate)`: remembers a validation function to call whenever a validation is executed. If `validate` is not given, the validation function with said name is actually removed.

If you only want to use a single input parameter, then using the `useFormData` might be a bit overkill. Instead, import `useFormParameter`. Then use it in your React object using `const [value, setValue] = useFormParameter('fieldName')`. This then only access a single input field and you don't have to worry about the rest.

#### Validation

We just saw some validation properties. How does that work? The idea is that, before we send any data to the server, we want to do some basic checks. If the user for instance forgot to insert a value, then this is most likely a simple mistake. We don't want to send any data to the server (which would count as a submission) but we want to immediately inform the user that something went wrong. This check is called validation.

Every input field can have a validation function, and through `saveValidationFunction(name, validate)` it's possible to add another validation function `validate(input)`. If everything is OK, this `validate` function should return something falsy, usually nothing (`undefined`). If there is a problem, a string should be given detailing the problem.

Before the form is submitted, the form calls all the validation functions. If any of them fails (returns a non-falsy value) then the form is not submitted. Instead, all the given strings are stored in the `validation` object, which could be something like `{x: "Field is empty", y: "Unit is missing"}`.

Every input field automatically has a default validation function. It varies per field what it is, though often it's a non-empty check. You could also easily add a validation function to a field through for instance `<IntegerInput name="ans" validate={(input) => input[ans].length < 4 ? 'Too short' : undefined} />`.

#### Feedback function

After a submission is sent to the server and a result comes back, this is updated in the history. This automatically also calls the so-called feedback function. This function `getFeedback` gets as parameters `getFeedback({ state, input, progress, prevProgress, shared })`. These are as follows.

- `state`: the state object.
- `input`: the last input that was submitted.
- `progress`: the new progress that was returned from the server.
- `prevProgress`: the previous progress before we submitted it to the server.
- `shared`: everything defined in the shared file. (Like the `checkInput` function if it's exported. Maybe it's useful.)

The `getFeedback` function can be manually passed to the Exercise when defining it, like `Exercise = () => <SimpleExercise Problem={Problem} Solution={Solution} getFeedback={getFeedback} />`. It's then used. If none is passed, a default function is made, based on the `checkInput` function, assuming it's exported from the shared file.

The `getFeedback` function should return an object. This object can be something like `{ main: false, ans1: true, ans2: false }`. The `main` key is special: if that is given, it gives a notification under the input space, saying that the exercise is correct (on true) or incorrect (on false). A custom message can also be provided. The other parameters are related to fields. If a field realizes that the feedback object has a result specified with the same name as the field, then the link is made. The field then shows a correct result (green checkmark) or an incorrect result (red cross). Again, a custom message can be passed along if desired.

#### InputSpace

Most problems have a question, like "solve 3*x = 18", and an input space where a user can insert an answer. Something like "x = [ .... ]" with an input field. When a student just gives up on an exercise, without inserting anything, it would be more clean to hide the input field. This can be done by putting it in an `InputSpace` wrapper. 

To do so, first import it using `import { InputSpace } from '../../form/Status'`. Then, in your Problem component, use it like `Problem = ({a, b}) => <><Par>Solve {a}*x = {b}.</Par><InputSpace><Par><IntegerInput id="ans" label="x" /></Par></InputSpace></>`. Everything in this input space is then hidden whenever an input space is not required. All the other text is always visible.

If you want to put a replacement text in place of the input space, then it's also possible to use the `AntiInputSpace` wrapper, imported in the same way. The contents of this one are only visible when the input space is *not* visible.

### WhenDone and WhenNotDone

Sometimes you may want to show a hint for a question, which may be hidden when the exercise is done. (Whether a submissions has been done or not.) In this case you can use `import { WhenDone, whenNotDone } from '../../form/Status'` to import these conainers. Then, in your Problem component, use it like `Problem = ({a, b}) => <><Par>Solve {a}*x = {b}.</Par><InputSpace><Par><IntegerInput id="ans" label="x" /></Par></InputSpace><WhenNotDone><Par>Hint: divide {b} by {a}.</Par></WhenNotDone></>`.

### StepExercise

One step more complicated than a `SimpleExercise` is the `StepExercise`. This exercise lets you formulate a main question. If the user solves it: great! If he gives up, it's instead split up into subquestions, which he can then solve one by one. This allows us to figure out what exactly he's struggling with.

There's three important differences compared to the `SimpleExercise`. Let's walk through them.

- In the `checkInput` function there is now a third parameter `checkInput(state, input, step)`. This `step` parameter can be 0 (the user made an attempt at the main problem) or 1, 2, 3, ... when he's at a certain step. (Yes, step 1 relates to step 1. We don't start counting at 0 here.) The `checkInput` function should then return `true` or `false` *for the given step*.

- The `Exercise` is now defined as `Exercise = () => <StepExercise Problem={Problem} steps={steps}>`. (A `getFeedback` function is optional again.) In this case the `Problem` is the main problem. The `steps` parameter is an array `[{Problem, Solution}]` with the sub-problems and sub-solutions of each of the steps. These sub-problems/sub-solutions work just like the regular problems/solutions.

- The `data` object in the shared directory must have a `steps` parameter. This must be an array, and for every step it must contain either a `skill` or a `skill combiner` that details the skills that have to be executed to solve the given step.

Everything else is set up automatically for you. It's an easy way to generate exercises that can be split up whenever the user requires it.