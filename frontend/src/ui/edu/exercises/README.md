# The Step-Wise front-end exercise system

To understand how the front-end exercise system of Step-Wise works, first read about the [back-end exercise system](../../../../../shared/edu/exercises/). You'll need that knowledge for the part below. It explains how to program your own exercises in the front-end.


## The front-end exercise file

Every exercise has a shared file and a front-end file. The front-end file must export a React component as default export. It must be positioned in the folder `front-end/src/ui/edu/exercises/exercises` and its file name must equal its `[exerciseId].js`. And generally that's all! There are no further rules.

So how does an exercise access its data? This is done through React Contexts. After all, every exercise is placed in an `ExerciseContainer`, which gives you access to `ExerciseData`. Just follow the following steps.

- At the top of the file put `import { useExerciseData } from '../ExerciseContainer'`.
- Within the React component put `const { state, progress, ... } = useExerciseData()`, where you important all the parameters that you need.

There are various parameters in the `ExerciseData`. These are:

- `state`: the `state` object generated by the `generateState` function for this exercise.
- `progress`: the last `progress` object for the exercise..
- `history`: an array `[{action: { ... }, progress: { ... }}, ...]` of earlier actions with resulting progress objects. The initial `progress` is always an empty object `{}` so this is not in the history. The last `progress` object from the `history` array of course equals the current `progress` parameter.
- `submitting`: a boolean that is set to true when an action has been submitted to the server and we're still waiting for a response.
- `submitAction`: the function used to submit an action to the server. Just call `submitAction(action)` to send an action to the `progressAction` handler.
- `startNewExercise`: the function used to start up a new exercise. This can only be called when the exercise is done. Then call `startNewExercise()`. (No input is required.)
- `shared`: all the objects exported from the `shared` file for this exercise, including `data`, `generateState` and `processAction` but also anything else that's exported, like potentially `getSolution` and `checkInput`.

Using this data, your React component should render the exercise appropriately. It is your responsibility to:

- Show the exercise.
- Allow the student to do something with it.
- When the user has a response ready, submit an action to the server to check it.
- Show if the response is correct, based on the new `progress` object.
- If the exercise is done, allow the student to start a new exercise.

If you do all that, you have a valid Exercise!


## Specific types of exercises

So far we have explained exercises in their most general form. Any exercise satisfying the above requirements is a valid exercise. Now we will look at specific types of exercises, which are used more commonly.


### The SimpleExercise type

The `SimpleExercise` is an exercise which can receive an input (possibly with multiple numbers or pieces of data) which is then judged as "correct" or "incorrect". It doesn't get any simpler than that.

Setting up a `SimpleExercise` yourself is relatively easy. After all, the `SimpleExercise` component handles all the intricacies behind the scenes. What you need to do is the following.

- Import the `SimpleExercise` component using `import SimpleExercise from '../types/SimpleExercise'`. (Hint: copy an existing exercise, so everything is in place already.)
- Use as default export a function `() => <SimpleExercise Problem={Problem} Solution={Solution} />`. The given `Problem` and `Solution` should be React components that you define yourself.
- Define a `Problem` React component of the form `(state) => <div>Put the problem here</div>`. So an example is `Problem = ({ a, b }) => <div>Calculate {a} + {b}. [Add an input field]</div>`. How to add input fields is explained below, when discussing forms.
- Define a `Solution` React component of the form `(state) => <div>Put the solution here</div>`. So an example is `Solution = ({ a, b }) => <div>The solution of {a} + {b} is {a + b}.</div>`.

Quite often the `Problem` only depends on the `state`, so the above set-up works. For the `Solution` it is often useful to have access to more data. In this case, you can import all `ExerciseData` too. For instance, if it is difficult to calculate the solution, and you've already programmed this in a `getSolution` function in the `shared` file, you can just import it!

```javascript
function Solution(state) {
	const { shared: { getSolution } } = useExerciseData()
	const { a, b, answer } = getSolution(state)
	return <div>The solution of {a} + {b} is {answer}.</div>
}
```

This allows you to keep a very simple `Solution` component, keeping all the code to calculate exercise solutions in the `shared` file.


### The StepExercise type

One step more complicated than a `SimpleExercise` is the `StepExercise`. This exercise lets you formulate a main question. If the user solves it: great! If they give up, the main question is split up into subquestions, which they can then solve one by one. This allows us to figure out what exactly the student is struggling with, and for the student it is nice to be guided through the problem as well.

To implement a `StepExercise` in the front-end, there are two important differences.

- Import the `StepExercise` component instead, using `import StepExercise from '../types/StepExercise'`.
- Set it up using `<StepExercise Problem={Problem} steps={steps} />`. There are two parameters here.
	- The `Problem` is the main problem, as a React component. Think of `({ a, b, c }) => <div>Calculate {a} + {b}*{c}.</div>`
	- The `steps` parameter must be an array of the form `[{ Problem: ..., Solution: ... }, { Problem: ..., Solution: ... }, ...]`, where each individual step has its own `Problem` and `Solution`. You can think of each step as a `SimpleExercise`.

If you set it up like this, the `StepExercise` component will deal with all the intricacies (how to display the steps, when to show the solution, how to start a new exercises) all by itself. You do not need to worry about it.


## Extra support for exercises

When setting up problems and solutions, there are a few things that might help you out. We will examine the most important ones.


### Getting extra exercise data

As was mentioned before, every exercise is placed in an `ExerciseContainer`. This allows you to load in all `ExerciseData` in any child component. Just use `const { state, progress, shared, ... } = useExerciseData()` to load in whatever you need. This also lets you access all data and functions from the `shared` file.


### The ExerciseWrapper

The `SimpleExercise` and `StepExercise` wrap each exercise in an `ExerciseWrapper`. This again provides extra functionalities. (Note that these are not accessible to manually programmed exercises.) 


#### Forms and input fields

The `ExerciseWrapper` wraps the exercise in a `Form` component. This allows you to use a variety of input fields. For instance, you can write `<IntegerInput id="ans" />`. This does three things.

- It places a nicely formatted input field in the exercise that only accepts integers.
- It stores the entered number within the `Form` under the name `ans`.
- When submitting the exercise, the `input` object will have a parameter `ans` containing the entered number.

There is a large variety of [input components](ui/form/inputs/). The `Form` component itself also provides you with a ton of possibilities. You can read about them in the [form documentation](ui/form/).


#### Validation of input

When a student submits an exercise, first the input is *validated* by the form. This means something like "check for obvious errors". If a field is still blank, or if a `FloatUnit` field has a number but misses a unit, then the validation fails. There is an obvious error.

When the validation fails, no submission to the API/server is made. Nothing is stored and no mastery scores are updated. Instead, any input field which failed validation will give a warning to the student. 

You can define which validation to perform through the validation function. Just add it to the field like `<IntegerInput id="ans" validate={positive} />` if you for example want to ensure that the student fills in positive values. (Sidenote: in this case it's better to just use `<IntegerInput id="ans" positive={true} />` to ensure no negative number can be filled in in the first place. But hey, it's an example.) 

Every type of input field has a couple of own validation functions. (One of them is default; often a non-empty check.) However, you can also define your own validation functions! A validation function should satisfy the following rules.

- The function receives the `input` value as input parameter.
- The function should output something falsy (like undefined) when everything works out.
- The function should output a string when there is a problem.

Very simply put, a validation function could be `newValidateFunction = (num) => (num < 0) && "This number cannot be negative!"`


#### Feedback function

The `ExerciseWrapper` also wraps your exercise in a `FeedbackProvider`. Let's take a look at what this does.

After a submission is sent to the server and a result comes back, the exercise updates its `history`. When this happens, the `FeedbackProvider` checks the last input and aims to provide feedback on this. It calls the provided `getFeedback` function like `getFeedback({ state, input, progress, shared })`. The given parameters are as follows.

- `state`: the exercise `state`.
- `input`: the last `input` that was submitted.
- `progress`: the most recent `progress` object that was returned from the server, after the given input.
- `shared`: everything defined in the shared file. (Like the `checkInput` function and `getSolution` function, if exported.)

The `getFeedback` function can be manually defined! If you want to set up your own `getFeedback` function, then you have to let it return an object. This object can be something like `{ main: false, field1: true, field2: false, field3: { correct: false, text: "Check your unit." } }`. There are a few rules.

- If you give a field the `false` property, the field gets a red border, noting it's incorrect. It will add a default incorrect message like "Sorry, wrong answer."
- If you give a field the `true` property, the field gets a green border, noting it's correct. It will add a default correct message like "Yes! Well done!"
- If you insert an object, note both whether the exercise was correct (`true` or `false`) and provided a text giving feedback.
- The `main` field is special: if you put feedback under this ID, then it will appear under the entire exercise as an extra feedback bar!

After you defined your `getFeedback` function, make sure to include it into the exercise, for instance through `Exercise = () => <SimpleExercise Problem={Problem} Solution={Solution} getFeedback={getFeedback} />`.

If you do not specify a `getFeedback` function yourself, the `SimpleExercise` and `StepExercise` components will try to make a feedback function themselves from the `checkInput` function. 

Very often, you'll want to provide feedback to parameters in a default way. For instance, for `FloatUnit` parameters, you want to first check the unit, if that matches check the number, and so forth. In this case the `getInputFieldFeedback` function comes in very handy! You might see it at various example exercises.


### InputSpace and AntiInputSpace

Most problems have a question, like "Solve `3*x = 18`" including an input field where the student can insert an answer. This will look something like "x = [ .... ]". When a student just gives up on an exercise, without inserting anything, it would be more clean to hide the input field. This can be achieved by putting the input field in an `InputSpace` wrapper. 

To do so, first import it using `import { InputSpace } from 'ui/form'`. Then, in your Problem component, use it like `Problem = ({a, b}) => <><Par>Solve {a}*x = {b}.</Par><InputSpace><Par><IntegerInput id="ans" label="x" /></Par></InputSpace></>`. Everything in this input space is then hidden whenever an input space is not required. All the other text is always visible.

If you want to put a replacement text in place of the input space, then it's also possible to use the `AntiInputSpace` wrapper, imported in the same way. The contents of this one are only visible when the input space is *not* visible.

### Hint and AntiHint

Sometimes you may want to show a hint for a question, which may be hidden when the exercise is done. (Whether a submissions has been done or not.) In this case you can use `import { Hint, AntiHint } from 'ui/form'` to import these conainers. Then, in your Problem component, use it like `Problem = ({a, b}) => <><Par>Solve {a}*x = {b}.</Par><InputSpace><Par><IntegerInput id="ans" label="x" /></Par></InputSpace><Hint><Par>Hint: divide {b} by {a}.</Par></Hint></>`.
